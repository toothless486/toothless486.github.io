---
title:  "1717 집합의 표현"
classes: wide
categories:
    Algorithms
tags:
    Disjoint-Set
---
### Disjoint Set

- 서로소 집합
- Union , Find 2가지 연산으로 구성되어이 있다.
- Union : 두 개의 집합을 하나의 집합으로 합친다.
- Find : 어떤 원소가 속하는 집합 중 Root를 반환한다. 어떤 원소의 Root를 반환하며 서로 같은 집합에 속해 있는지 확인할 수 있다.
- 가장 처음에는 배열 Arr[i] = i 로 초기화한다.

### 경로 압축

시간복잡도가 O(N)이 걸리는 경우는 다음과 같다.

<div class="mermaid"> 
flowchart LR
id1((1))---id2((2))---id3((3))---id4((4))---id5((5))---id6((6))---id7((7))
</div>

Find(7)을 할 때, 1까지 올라가면서 만난 값은 모두 7과 같은 집합에 포함되어 있다. Find를 할 때 만난 모든 값의 Parent를 Root로 바꾸어주면 다음 그림과 같이 된다.

<div class="mermaid"> 
flowchart TD
id1((1))---id2((2))
id1((1))---id3((3))
id1((1))---id4((4))
id1((1))---id5((5))
id1((1))---id6((6))
</div>

### 느낀 점

- 경로 압축을 통해서 시간초과를 해결 해야한다.
- while 문을 돌린 것보다 재귀를 통해 경로압축을 한 것이 더 빠르다는 점

### 코드

```
#include <iostream>
using namespace std;

int n, m;
int arr[1000001];

int Find(int x)
{
    if(x == arr[x])
    {
				return x;
    }

    int y = Find(arr[x]);
    arr[x] = y;
    return y;
}

void Union(int a, int b)
{
    int aParent = Find(a);
    int bParent = Find(b);
		arr[aParent] = bParent;
}

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    
    cin >> n >> m;
    for(int i=1; i<=n; i++)
    {
				arr[i] = i;
    }

    while(m--)
    {
				int c,  a, b;
				cin >>  c >> a >> b;
			
				if(c == 0)
				{
				    Union(a, b);
				}
				else
				{
				    if(Find(a) ==  Find(b))
				    {
					cout << "YES\n";
				    }
				    else
				    {
					cout << "NO\n";
				    }
				}
    }
    return  0;
}
```

### 문제 해결

1. 시간 초과
2. 런타임 에러 (NZEC) [https://help.acmicpc.net/judge/rte/NZEC](https://help.acmicpc.net/judge/rte/NZEC)
    1. n의 사이즈를 제대로 확인하자 !